# Survival analysis 

```{r setup_ch13, include=FALSE, results='hide'}
#### from settings13.R (sina rueegger) ####
## packages
library(MASS)
library(colorspace)
library(ggplot2)
library(biostatUZH)
library(xtable)
library(survival)
library(reporttools)
library(gplots)
library(reporttools)
library(beeswarm)

## colours
col.blue <- rgb(55,126,184, max = 255)
col.red <- rgb(228,26,28, max = 255)
col.orange <- rgb(225,127,0, max = 255)
col.green <- rgb(77,175,74, max = 255)
col.lightgreen <- rgb(178,223,138, max = 255)
col.text <- "black"
colors <- c(col.red, col.green, col.blue, col.orange)

## functions
f.nam <- dir("functions")
sapply(f.nam, function(x) source(paste("functions", x, sep = "/")))
format.bigmark <- function(...)
  {
    format(..., big.mark = "'")
  }

## parameters
histborder <- "black"#"white"
histcol <- gray(0.4)
pch.mean <- 8 # 4, 16
pch.median <- 17
lwd.lines <- 2
lwds <- 1.5 ## points 

dig <- 2

colpal4 <- c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3")
colpal4.pastell <- c("#FBB4AE", "#B3CDE3", "#CCEBC5", "#DECBE4")
colpal2 <- colpal4[2:3] 
colpal3 <- colpal4[1:3] 

## dataprep (Mundhöhlenkrebsdaten)
sakk <- read.csv("data/SAKK1094.csv", sep = ",", as.is = TRUE)
## ps : WHO performance status
sakk$primarysite <- factor(sakk$primarysite, levels = 1:4, 
                           labels = c(" (Oral cavity)", 
                                      " (Oropharynx)", 
                                      " (Hypopharynx)", 
                                      " (Larynx)")) ## site of primary tumor
## t : tumor stage
sakk$n <- factor(sakk$n) ## nodal stage


## global R-chunk settings
par(las=1)
```


A common form of data in clinical trials is survival (time to event) data. 
Survival outcomes can often be considered as continuous,
but are usually quite skewed. 
Moreover, the issue of *censoring* requires special techniques for statistical 
analysis.

## Analysis of survival outcomes 

### Censoring
A survival time $T$ is called *(right-)censored*, if it is known that the
individual has survived up to time $T$, but whose survival status past that
point is not known. For example, the study might be finished before all patients 
have died,
a patient might decide to withdraw from the study or a
patient might die from some other reason, for example in a car crash.

A central assumption in survival analysis is that the censoring time is 
independent from the survival time (non-informative censoring).

```{r dataprep-sakk, echo = FALSE}
howmany <- 10
howmany2 <- 5

## table
os <- as.character(Surv(round(sakk$os, 1), sakk$death))
tttd <- as.character(Surv(round(sakk$os, 1), sakk$death))
## sex <- factor(as.numeric(sakk$sex == "F"), levels = 0:1, labels = c("Mann", "Frau"))
sex <- factor(as.numeric(sakk$sex == "F"), levels = 0:1, labels = c("Male", "Female"))
trt2 <- factor(sakk$trt, levels = c("A", "B"), labels = c("RT+CT", "RT"))

sakk.tab <- cbind(sakk$upn, sex, disp(sakk$age, 1), trt2, sakk[c("n", "t", "ps")], os, tttd)
sakk.tab <- sakk.tab[1:howmany,]
sakk.tab <- sakk.tab[order(sakk$os[1:howmany], decreasing = TRUE),]

sakk.tab <- head(sakk.tab, howmany2)
## dimnames(sakk.tab)[[2]] <- c("Patient", "Geschlecht", "Alter", "Behandlung", "LK-Status", "Stadium", "PS", "OS", "TTT")
dimnames(sakk.tab)[[2]] <- c("ID", "Sex", "Age", "Treatment", "LK", "Stage", "PS", "OS", "TTT")
sakk.tab$ID <- 1:nrow(sakk.tab)


time <- sakk$os
event <- sakk$death
treat <- factor(sakk$trt, labels = c("RT+CT", "RT"))

sakk.rtct <- sakk[sakk$trt == "A", ]
sakk.rt <- sakk[sakk$trt == "B", ]
``` 


:::{.example #sakk}
The Chemotherapy study [@Huguenin2004] is a randomized study to compare two treatments 
for head and neck cancer on $`r nrow(sakk)`$ patients: 
Combination of radiotherapy and chemotherapy (RT+CT)
($n=`r sum(sakk$trt == "A")`$) versus radiotherapy alone (RT) 
($n=`r sum(sakk$trt == "B")`$). The primary outcome is survival time (in years) 
from start of treatment. Figure \@ref(fig:sakkTimes) shows data for the 
survival times of the first 10 patients. The survival time is measured 
from the start of treatment (starting point $0$) and it ends if a patient 
either dies or is censored.
:::



```{r sakkTimes, fig.cap = "Survival times for a selection of patients from Example \\@ref(exm:sakk).", echo = FALSE}
par(mar = c(2, 4, 3.5, 0.2), las = 1)
sakk.plot <- sakk[1:howmany,]
sakk.plot <- sakk.plot[order(sakk.plot$os, decreasing = FALSE),]
plot(0, 0, xlim = c(0, 16), ylim = c(1,howmany), type = "n", 
     ylab = "Patient ID", xaxt = "n", yaxt = "n")
axis(2, 1:howmany, howmany:1)
segments(rep(0, howmany), 1:howmany, sakk.plot$os, 1:howmany, 
         col = ifelse(sakk.plot$death == 1, col.red, col.green), lwd = lwd.lines)

id <- which(sakk.plot$death == 0)
segments(rep(0, length(id)), id, max(sakk.plot$os)+2, id, col = col.green, 
         lwd =
         lwd.lines, lty = 2)

points(sakk.plot$os, 1:howmany, 
       col = ifelse(sakk.plot$death == 1, col.red, col.green), 
       pch = ifelse(sakk.plot$death == 1, 4, 1), lwd = lwd.lines)
mtext("Time since start of treatment (in years)", 3, line = 2.5)
axis(3)
legend("bottomright", bty = 'n', pch = c(4, 1), col = c(col.red, col.green), 
       cex = 1.2, lwd = lwd.lines, legend = c("Death", "Censored"))
```


Table \@ref(tab:sakkdata) shows a selection of variables for the first five 
patients. The notion overall of survival (OS) denotes survival without any further 
conditions (in contrast to, e.g., progression free survival).
In this example, OS is the survival time in years and the $+$ stands for
"censored". The format of the variable OS (with $+$ for censored) is the output 
of the `R` function `survival::Surv()`.
<!-- It combines three variables from the data: an event -->
<!-- indicator, time to event and time to last follow-up. -->
<!-- Patients with no time to event are censored at their last follow-up. -->
<!-- The function Surv() needs the times (combined in one variable) and the events -->
<!-- for each patient. -->


```{r sakkdata, results='asis', echo = FALSE}
# Load necessary libraries
library(knitr)
library(kableExtra)

# Create the table
kable(sakk.tab[, 1:8], align = "lcccc", 
      caption = "Data from selected patients in the Chemotherapy study. OS is the overall survival time, a $+$ indicates censoring, LK are the lymph nodes and PS the performance status.", 
      booktabs = TRUE, escape = FALSE, caption.placement = "top", label = NA, row.names = FALSE) %>%
  kable_styling(latex_options = c("striped", "hold_position"), full_width = FALSE)
```

### Survival function and curve

The *survival function*

\begin{equation*}
S(t) = \Pr(T > t)
\end{equation*}

gives the probability of survival at least up to time $t$. The *survival curve* is a plot of $S(t)$ versus $t$, see Figure \@ref(fig:survfct).


```{r survfct, fig.cap = "Examples of survival curves for three different survival functions.", echo = FALSE}
shapes <- c(1.5, 1, 3)
scales <- c(4, 10, 3)

par(las = 1)
ts <- seq(0, 15, by = 0.01)
plot(0, 0, type = 'n', xlim = range(ts), ylim  = c(0, 1), xlab = "Survival time (in years)", ylab = "Probability of survival")
for (i in 1:length(shapes)){lines(ts, 1 - pweibull(ts, shape = shapes[i], scale = scales[i]), col = colors[i], lwd = 2, lty = 1)}
#legend("topright", bty = 'n', paste("Weibull(a=", shapes, ", b=", scales, ")", sep = ""), col = 1:length(shapes) + 1, lwd = 2, lty = 1)
``` 


#### Life table method {-}

The *life table* method is a classical approach to estimate the survival function $S(t)$. It is based on a partition of the time axis into time intervals $i=1,\ldots,I$ of typically equal length. The *risk of death* $r_i$ in interval $i$ is estimated as

\begin{equation*}
\hat r_i = \frac{\mbox{# patients which died in interval
$i$}}{\mbox{# patients at risk in interval $i$}} = \frac{d_i}{n_i}
\end{equation*}

By convention, observations censored in interval $i$ contribute half to the 
number of patients at risk. Note that the denominator $n_i$ is monotonically decreasing as a function of time.

The survival function is then estimated as

\begin{equation*}
\hat S(i) = \prod_{t=1} ^i(1 - \hat r_t) = 
(1 - \hat r_1) \times \ldots \times (1 - \hat r_i).
\end{equation*}

Wald confidence intervals can be calculated for $\hat S(i)$, $\log \hat S(i)$ or 
$\log \{-\log \hat S(i)\}$ with appropriate back-transformation. The corresponding standard errors can be found in textbooks,
e.g. @collett (Section 2.2).

```{r sterbetafel, quiet=TRUE, echo = FALSE}
Imax <- ceiling(max(sakk.rtct$os))
i <- 1:Imax
a <- rep(NA, Imax); d <- a; c <- a

for(i in 1:Imax){
    a[i] <- sum(sakk.rtct$os >= (i - 1))
    d[i] <- sum((sakk.rtct$os >= (i - 1)) & 
                  (sakk.rtct$os < i) & 
                  sakk.rtct$death == 1)
    c[i] <- sum((sakk.rtct$os >= (i - 1)) & 
                  (sakk.rtct$os < i) & 
                  sakk.rtct$death == 0)
}

n <- a - c / 2; r <- d / n; s <- 1 - r; S <-  cumprod(s)
zaehler <- sqrt(cumsum(d / (n * (n - d))))
nenner <- (cumsum(log((n - d) / n)))
se.logS <- zaehler / nenner
``` 


:::{.example #sakk name="continued"}
Table \@ref(tab:sakklifetable) shows the estimated survival function 
(values for each interval/year) in the RT+CT group from 
Example \@ref(exm:sakk). Figure \@ref(fig:KMlifetable) shows 
the estimated survival curve with 95\% confidence intervals for every year (in red).
:::


```{r sakklifetable, results = "asis"}
output <- data.frame(1:Imax, a, d, c, n, round(r, 2), round(s, 2), round(S, 2))
output <- rbind(
c("Interval (year)",  "\\# patients at beginning of interval",  
  "\\# deaths during interval", "\\# censored", "\\# patients at risk", 
  "$r_i$",  "$1-r_i$", "$\\hat S(i)$"), output) 

kable(output,align = c("c", rep("r", 7)), 
      caption = "Life table method in the RT+CT group from
      Example \\@ref(exm:sakk).", col.names = NULL) 
``` 

#### Kaplan-Meier estimate of the survival function {-}

In many studies, the exact follow-up time for each individual is known. 
Aggregation in arbitrary time intervals can then be avoided. 
The *Kaplan-Meier estimate* of the survival function uses intervals 
which contain only one event, so $d_i \in \{0, 1\}$ (if there are no ties). 
Application of the life table method to these intervals yields the Kaplan-Meier
estimate, a step function with  jumps of relative size
\[
1/\mbox{number of subjects at risk}
\]
at the time of each event. 

There are some critical assumptions in Kaplan-Meier estimation [@SN_KMcurves]: 
First, at any time, patients who are censored have the same survival
prospects as those who continue to be followed.
If censoring is related to survival for some patients,
the estimated survival probabilities would be biased.
Secondly, survival probabilities are the same for subjects recruited early
and late in the study. 
In a long term study, the case mix may change over the period of recruitment, 
or there may be an innovation in ancillary treatment.
Last, the event happens at the time specified. This could be a problem,
for example, if the event were recurrence of a tumor which would be detected at
a regular examination (interval censoring).

The results of a survival analysis depend upon the choice of time scale: 
time since study entry (i.e. randomisation in RCTs), calendar time, or age.
For example, consider the following dataset: 

```{r, echo = FALSE}
Subject <- c(1:10)
Sex <- c("F","M","M","F","M","M","F","M","M","F")
AgeEntry <- c(29.3,25.2,22.1,32.2,33.1,42.1,35.2,27.0,44.8,51.5)
AgeExit <- c(53.8,42.4,52.8,54.4,52.6,57.1,50.4,47.2,62.7,70.6)
DateEntry <- as.Date(c("13/06/1965", "23/10/1972", "03/03/1959", "10/10/1967", "02/01/1960", "09/01/1975", "05/08/1953", "10/10/1969", "02/03/1972", "01/11/1970"), "%d/%m/%Y")
dummy <- rep("31/12/1989", 10)
dummy[5] <- "04/07/1979" 
dummy[7] <- "03/10/1968"
DateExit <- as.Date(dummy, "%d/%m/%Y")
Event <- c(0,0,0,0,1,0,1,0,0,0)
cohort <- data.frame(Subject, Sex, DateEntry, AgeEntry, DateExit, AgeExit, Event)

print(cohort)
```
With this dataset, the three time scales look as follows: 
```{r}

## Funktion zum Plotten von Überlebenszeiten. observed ist Indikator für nicht-zensierte Beob.
## obsLabels kann Vektor mit y-Labels für die Zeiten sein.
timesPlot <- function (entry.times, times, observed, obsLabels = NULL, ...){
  n <- length (times)
  ## order times
  timesOrder <- c(1:n)#rev (order (times))     # rev um lange Dauern unten zu haben
#  entry.times <- entry.times[timesOrder]
  times <- times[timesOrder]
  observed <- observed[timesOrder]
  obsLabels <- obsLabels[timesOrder]
  ## plot points
  plot (times, 1:n, pch = ifelse (observed, 4, 19), col = ifelse (observed, 2, 1), cex=1.5, yaxt = "n", ..., xlim=c(min(entry.times), max(times)), lwd=1.5)
  ## plot corresponding lines
  for(i in 1:n){
    if(observed[i]==1)
      lines(rep(times[i],2),c(0,n+1),col=2, lty=2, lwd=1.5)
  }
  
  segments (entry.times, 1:n, times, 1:n)
  ## optional labeling
  axis (side = 2, at = 1:n, labels = 1:n, tick = TRUE)
}
par(mar = c(4,4,1,1), las=1)

par (font.lab = 1)
par(mfrow=c(1,3))
with(cohort,
     timesPlot (0, DateExit - DateEntry, xlab = "Time since study entry (in days)", ylab="Patient ID", observed = Event)
     )
#legend("topleft", pch=c(4, 1), cex=1.5, legend=c("Dead", "Censored"))
with(cohort,
     timesPlot (DateEntry, DateExit, xlab = "Calendar time (in years)", ylab="Patient ID", observed = Event)
     )
#legend("topleft", pch=c(4, 1), cex=1.5, legend=c("Dead", "Censored"))

with(cohort,
     timesPlot (AgeEntry, AgeExit, xlab = "Age", ylab="Patient ID", observed = Event)
     )
legend("topleft", pch=c(4, 19), cex=1.25, , col=c(2, 1), legend=c("Event", "Censored"))
```

| **Time scale**          | **Risk set at first event**                 | **Risk set at second event**             |
|--------------------------|---------------------------------------------|-------------------------------------------|
| Time since study entry   | {1, 2, 3, 4, 5, **7**, 8, 9, 10}           | {1, 3, 4, **5**, 8}                       |
| Calendar time            | {1, 3, 4, 5, **7**}                        | {1, 2, 3, 4, **5**, 6, 8, 9, 10}          |
| Age                      | {1, 3, 4, 5, 6, **7**, 9}                  | {1, 3, 4, **5**, 6, 9, 10}                |


The risk set depends on the time scale. Then how do we select a time scale? 
Usually, the time scale with the strongest relationship to the event rate 
is used. In RCTs, survival is usually analysed in relation to the 
time since randomisation. An additional time scale can be 
incorporated as a covariate. For example, one can 
adjust for the age of the subjects by including age at diagnosis (which is 
fixed for every subject) in a short follow-up, and by including age 
itself as a time-varying covariate in a long follow-up.


:::{.example #sakk name="continued"}
Figure \@ref(fig:KMlifetable) compares the Kaplan-Meier estimate of
the survival curve in Example \@ref(exm:sakk) for the RT+CT group
to the estimate obtained with the life table method 
using yearly intervals. 
The Kaplan-Meier estimate can be calculated and plotted with the following `R` code.
The option `conf.int = TRUE` shows a dotted confidence band and the option
`mark.time = TRUE` would show censoring events (see Figure \@ref(fig:KMbiased)).
:::

```{r survplot1, echo = TRUE, fig.show='hide'}
sakk.surv <- survfit(Surv(os, death) ~ 1, data = sakk.rtct, 
                     conf.type = "log-log")
plot(sakk.surv, conf.int = TRUE, mark.time = FALSE, lwd = 2, 
     col = col.blue, log = FALSE, xlab = "Survival time (in years)", 
     ylab = "Survival probability", xlim = c(0, Imax))
``` 


```{r KMlifetable, fig.cap = "Comparison of Kaplan-Meier method (blue) with life table method (red, with yearly 95\\% confidence intervals) to estimate the survival curve in the RT+CT group from Example \\@ref(exm:sakk).", echo = FALSE }
par(mar = c(4.5, 4, 0.1, 1), las = 1)
# par(mar = c(4.5, 4, 1.7, 1), las = 1)
myS <- c(1, S)
EF <- exp(1.96 * se.logS)
lower <- c(1, S ^ EF)
upper <- c(1, S ^ (1 / EF))

plot(sakk.surv, mark.time = FALSE, conf.int = TRUE, lwd = 2, col = col.blue, log = FALSE, xlab = "Survival time (in years)", ylab = "Survival probability", xlim = c(0, Imax))
lines(c(0:Imax), myS, lty = 2, lwd = 2, cex = 2, col = col.red) 
points(c(0:Imax), myS, col = col.red, pch = 16)

plotCI(x = 1:Imax, y = S, li= upper[-1], ui = lower[-1], add = TRUE, col = col.red, lwd = lwd.lines)
legend("topright", c("Kaplan-Meier", "Life Table"), lty = c(1, 1),
col = c(col.blue, col.red), lwd = 2, bty = 'n')
``` 


With `survminer::ggsurvplot`, a Kaplan-Meier estimate with additional risk 
table can be obtained as shown in Figure \@ref(fig:ggsurvplot).

```{r ggsurvplot, echo = TRUE, fig.cap="Kaplan-Meier estimate of the survival curve in the RT+CT group from Example \\@ref(exm:sakk), with risk table."}
library(survminer)
ggsurvplot(sakk.surv, risk.table = TRUE)
``` 
Based on the Kaplan-Meier curve we can now compute survival probabilities with confidence interval, for example at 5 years: 
```{r survprob, echo = TRUE}
summary(sakk.surv, times = 5)
``` 



It is important to be careful with censored data. 
Censored observations cannot be simply ignored, i.e. 
excluded, and they cannot be treated as non-censored. 
Doing so would lead to biased estimation of the survival function as 
illustrated in Figure \@ref(fig:KMbiased). 
Excluding censored observations means losing data on patients without events, 
so will *underestimate* the survival curve.
Treating them as non-censored, i.e. as death events, 
also leads to *underestimation* of the survival curve.

```{r survplot2b, fig.width = 7, fig.height = 3.5, echo = FALSE}
par(mar = c(4.5, 4, 1.7, 1), las = 1, mfrow=c(1,2))
#sakk.surv <- survfit(Surv(time, death)~ 1, data = sakk, conf.type = "log-log")
plot(sakk.surv, conf.int = TRUE, mark = "/", lwd = lwd.lines, col = col.blue, log = FALSE, xlab = "Survival time (in years)", ylab = "Survival probability", xlim = c(0, Imax))
lines(sakk.surv, lty = 1, mark = "/", lwd = lwd.lines, cex = lwd.lines, col = col.blue) 
title("Correct KM Curve")

sel <- which(sakk$death==1)

# drop all censored observations
sakk2 <- sakk[sel,]
sakk.surv2 <- survfit(Surv(os, death)~ 1, data = sakk2, conf.type = "log-log")

plot(sakk.surv2, conf.int = TRUE, mark = "/", lwd = lwd.lines, col = col.blue, log = FALSE, xlab = "Survival time (in years)", ylab = "Survival probability", xlim = c(0, Imax))
lines(sakk.surv2, lty = 1, mark = "/", lwd = lwd.lines, cex = lwd.lines, col = col.blue) 
title("Biased KM Plot")
``` 

```{r KMbiased, fig.cap = "Kaplan-Meier curves in the RT+CT group from Example \\@ref(exm:sakk) where censored observations are ignored (top right) and where censored observations are treated as non-censored (bottom right). On the left side (top and bottom) the correct Kaplan-Meier estimate is shown, the dashes indicate censoring events.", echo = FALSE, fig.width = 7, fig.height = 3.5}
par(mar = c(4.5, 4, 1.7, 1), las = 1, mfrow=c(1,2))
#sakk.surv <- survfit(Surv(time, death)~ 1, data = sakk, conf.type = "log-log")
plot(sakk.surv, conf.int = TRUE, mark = "/", lwd = lwd.lines, col = col.blue, log = FALSE, xlab = "Survival time (in years)", ylab = "Survival probability", xlim = c(0, Imax))
lines(sakk.surv, lty = 1, mark = "/", lwd = lwd.lines, cex = lwd.lines, col = col.blue) 
title("Correct KM Curve")

sakk3 <- sakk
# treat all censored as uncensored observations
sakk3$death <- sakk3$death<=1

sakk.surv3 <- survfit(Surv(os, death) ~ 1, data = sakk3, conf.type = "log-log")

plot(sakk.surv3, conf.int = TRUE, mark = "/", lwd = lwd.lines, col = col.blue, log = FALSE, xlab = "Survival time (in years)", ylab = "Survival probability", xlim = c(0, Imax))
lines(sakk.surv3, lty = 1, mark = "/", lwd = lwd.lines, cex = lwd.lines, col = col.blue) 
title("Biased KM Curve")
``` 


### Median survival time

The *median survival time* $t_{\small{\mbox{Med}}}$ (and other quantiles) 
can be easily read off the Kaplan-Meier estimate. A confidence interval for the
$t_{\small{\mbox{Med}}}$ can also be derived in this way.
The "square-and-add" method, see Appendix
\@ref(appCI:difference), can be used to compute a confidence interval for the 
difference in median survival time between two groups.

:::{.example #sakk name="continued"}
Figure \@ref(fig:sakkMedian) is a graphical illustration of the median 
survival time in the RT+CT group from Example \@ref(exm:sakk).
:::


```{r sakkMedian, fig.cap = "Median survival time in the RT+CT group from Example \\@ref(exm:sakk).", echo = FALSE}
km <- quantileKM(sakk.rtct$os, sakk.rtct$death, quant = 0.5, 
                 conf.level = 0.95)
km2 <- quantileKM(time, event, group = treat, quant = 0.5, 
                 conf.level = 0.95)
out <- km$quantities

math <- function (..., font = 3)
{
    ## unpack dot-dot-dot argument
    dots <- as.list (substitute (...[]))
    dots <- dots[2:(length (dots) - 1)]

    ## font extension
    font <- switch (font, "plain", "bold", "italic", "bolditalic")
    dots <- paste (font, "(", dots, ")")

    ## parse and build expression
    do.call ("expression", as.list (parse (text = dots)))
}

par(mar = c(4.5, 4, 0.1, 1), las = 1)
plot(sakk.surv, mark.time = FALSE, conf.int = TRUE, lwd = 2, col = col.blue, log = FALSE, xlab = "Survival time (in years)", ylab = "Survival probability", axes=F)
axis(2, at=c(c(0,2,4,5,6,8,10)/10), labels=c("0.0", "0.2", "0.4", "0.5", "0.6", "0.8", "1.0"))
box()
     
eps <- -.2
lines(c(0,out[1,5]), rep(0.5,2), col = col.text, lwd = lwd.lines)
lines(rep(out[1,3],2), c(0, 0.5), col = col.text, lwd = lwd.lines, lty=5)
lines(rep(out[1,3],2), c(eps, eps+0.1), col = col.text, lty=5, lwd = lwd.lines)

lines(rep(out[1,4],2), c(0, 0.5), col = col.text, lty=2, lwd = lwd.lines)
lines(rep(out[1,5],2), c(0, 0.5), col = col.text, lty=2, lwd = lwd.lines)

eps <- 0.1
axis(1, c(0, out[1,3:5], 5, 10, 15), c(0, round(out[1,3:4], 1), out[1,5], 5, 10, 15))

mtext(math(t[Med]), side = 1, line = 2.5, at = out[1,3]-0.5, adj = 0, font = 2, col = col.text)
``` 


```{r mediane, results = "asis"}
#km1 <- quantileKM(time / 365.25, event, group = cholestase, quant = 0.5, conf.level = 0.95)
#km2 <- quantileKM(time / 365.25, event, group = treat, quant = 0.5, conf.level = 0.95)

out <- km2$quantities
output <- data.frame(out[, 1:3], reporttools::displayCI(as.matrix(out[, 4:5]), digit = 1, text = "english"))
dimnames(output)[[2]] <- c("", "", "$t_{\\small{\\mbox{Med}}}$", "95\\%-CI")
output[,3] <- format(output[,3], digits = 2)
output[,4] <- as.character(output[,4])

output <- rbind(c("$n$", "Number of Deaths", "(in years)", "(in years)"), output)
rownames(output) <- c("", "RT + CT", "RT")

# Print the table using kable and kableExtra
kable(output, align = c("l", rep("r", 6)), 
      caption = "Median survival times with 95\\% confidence intervals of RT and RT+CT groups from Example \\@ref(exm:sakk).", 
      booktabs = TRUE, escape = FALSE, caption.placement = "top", label = NA) %>%
  kable_styling(latex_options = c("striped", "hold_position"), full_width = FALSE)

``` 



```{r sakkMedians, fig.cap = "Median survival times with 95\\% confidence intervals of RT and RT+CT groups from Example \\@ref(exm:sakk).", fig.width = 10, fig.height = 4}
p1 <- out[1,3]
p2 <- out[2,3]

ci.p1 <- out[1,4:5]
ci.p2 <- out[2,4:5]
l1 <- ci.p1[1]
l2 <- ci.p2[1]
u1 <- ci.p1[2]
u2 <- ci.p2[2]


par(mar = c(4, 6, 2, 0), cex=2)
plot(c(0,0), type = "n", xlim=c(0, 6), ylim = c(1.2, 1.8)
     , ylab="", 
xlab="Median survival time (in years)", axes=F)
axis(1, at=0:6, labels=0:6)
axis(2, at=c(1.7, 1.3), labels=c("RT", "RT+CT"), las = 1)
plotCI(y= c(1.3, 1.7), x = out[,3], li = out[,4], ui = out[,5] , col =
       c(col.green, col.blue), err = "x", add = TRUE, pch = 16, lwd = lwd.lines)
``` 


```{r ch19}
d <- p1-p2
dl <- d - sqrt((p1-l1)^2+(u2-p2)^2)
du <- d + sqrt((p2-l2)^2+(u1-p1)^2)
``` 
The median survival time in the two groups
with their respective CI are shown in Table \@ref(tab:mediane) and graphically in
Figure \@ref(fig:sakkMedians).


The difference in median survival time is `r round(d,1)` years 
(95\%-CI: from $`r round(dl,1)`$ to $`r round(du,1)`$ years) and is 
computed with the `R` function `biostatUZH::confIntSquareAdd()`:

```{r, echo=TRUE}
biostatUZH::confIntSquareAdd(theta1 = 3.9, lower1 = 2.2, upper1 = 6, 
                             theta2 = 2.4, lower2 = 1.8, upper2 = 3.8)
```








## Comparison of survival curves {#sec:breslow}

One has to be careful about what groups to compare.
Breslow's first rule of survival analysis states that:
"Selection into the study cohort, or into subgroups to be compared in 
the analysis, must not depend on events that occur after the start of follow-up".
*Survival by tumor response analysis* in oncology is an example that 
leads to biased estimates of the survival distributions, invalid statistical 
tests, and misleading conclusions. 
This bias results from the fact that responders must live long enough
for response to be observed; there is no such requirement for 
non-responders [@Anderson1983, @Anderson2008].
Another example where Breslow's rule is violated is a study reporting that
Oscar winners live longer [@oscarwinners]. As other scientists have noticed,
this study was subject to *survival bias* or *immortal time bias*
[@oscarwinners_reanalysis].



We now discuss how survival curves can be compared between groups. 
For example, the survival curves of the RT and RT+CT groups are shown in Figure \@ref(fig:sakkTwoGroups). Later, we show how to generate 
such a plot with the `R`function `ggminer::ggsurvplot`.

```{r sakkTwoGroups, fig.cap = "Kaplan-Meier curves for both groups in Example \\@ref(exm:sakk).", echo = FALSE}
par(mar = c(4.5, 4, 0.1, 1), las = 1)
sakk.surv1 <- survfit(Surv(time, death) ~ treat, data = sakk, conf.type = "log-log")
plot(sakk.surv1, mark = "/", conf.int = FALSE, lty = 1, lwd = 2, col = c(col.red, col.green), log = FALSE, xlab = "Survival time (in years)", ylab = "Survival probability")
#lines(pbc.surv1, mark = "", lty = 1, lwd = 2, cex = 2, col = c(2, 4)) 
legend("topright", c("RT+CT", "RT"), lwd = 2, lty = 1, col = c(col.red, col.green), bty = 'n', cex=1.5) 
##text(7, 0.6, paste("Log-Rank p-value = ", formatPval(pwert2, 2), sep = ""), adj = 0, font = 2, cex=1.5)
``` 



### Log-rank test

```{r ch20, echo = FALSE, quiet = TRUE}
test2 <- survdiff(Surv(time, death) ~ treat, data = sakk)
pwert2 <- signif(1-pchisq(test2$chisq, df = 1), 2)
``` 

The *log-rank test*, also called *Mantel-Cox test*, 
quantifies the evidence against the null hypothesis of
equal survival curves $S_A(t) = S_B(t)$ , in groups A and B,
for all times $t$ with a $P$-value. The method compares 
the *observed number* of events with the corresponding
*expected number* of events (under the null hypothesis $H_0$) in each group.

```{r ch20b, echo = TRUE}
(survdiff(Surv(time, death) ~ treat, data = sakk))
``` 


The two survival curves can be shown in one plot using the following code,
see Figure \@ref(fig:ggch21):


```{r ggch21, echo = TRUE, fig.height=5.5, fig.cap="Kaplan-Meier curves for both groups in Example \\@ref(exm:sakk) obtained with ggsurvplot."}
sakk.surv1 <- survfit(Surv(time, death) ~ treat, data = sakk, conf.type = "log-log")
ggsurvplot(sakk.surv1, risk.table = TRUE, conf.int = TRUE, pval = TRUE)
``` 


### Hazard function

The mortality rate can also be used to describe the risk of death 
in a certain interval: 
\begin{eqnarray*}
\frac{\mbox{Death risk in interval}}{\mbox{Length of interval}}.
\end{eqnarray*}

The mortality rate is conditional on having survived up 
to the interval of interest. 
The *hazard function* is obtained by making the length of the intervals 
very small: 

\begin{equation*}
h(t)= \lim\limits_{h \rightarrow 0} \frac{\P(t < T < t+h \given T>t)}{h}. 
\end{equation*}  

The hazard function and the survival function have a one-to-one relationship:

\begin{equation*}
S(t) = \exp\left(- \int_0^t h(u) du \right).
\end{equation*}
This implies that the *cumulative hazard function* $H(t)$ is directly related to the survival function:
\begin{equation*}
H(t) = \int_0^t h(u) du = - \log S(t).
\end{equation*}



Figure \@ref(fig:survhazard) shows the survival and hazard functions for a constant hazard rate ($\mbox{HR} = 2$, top) and for an increasing hazard rate (bottom).


```{r survhazard, fig.cap = "Survival function and hazard function: constant hazard (top) and non-linearly increasing (bottom)", echo = FALSE}
shapes <- c(1, 1)
scales <- c(1, 2)

par(mfrow = c(2, 2), mar = c(4.5, 4, 1, 1), las = 1)
ts <- seq(0, 5, by = 0.01)

# hazards
plot(0, 0, type = 'n', xlim = range(ts), ylim  = c(0, 3), xlab = "Time t", ylab = "Hazard function h(t)")
for (i in 1:length(shapes)){
    St <- 1 - pweibull(ts, shape = shapes[i], scale = scales[i])
    ht <- dweibull(ts, shape = shapes[i], scale = scales[i]) / St
    lines(ts, ht, col = colors[i], lwd = 2, lty = 1)
    }
# text(0.1, 2.75, "HR = 2", adj = 0, font = 2, cex=1.5)


# S(t)
plot(0, 0, type = 'n', xlim = range(ts), ylim  = c(0, 1), xlab = "Time t", ylab = "Survival function S(t)")
for (i in 1:length(shapes)){
    St <- 1 - pweibull(ts, shape = shapes[i], scale = scales[i])
    lines(ts, St, col = colors[i], lwd = 2, lty = 1)
    }


shapes <- c(1.5, 1, 3)
scales <- c(4, 10, 3)

shapes <- c(1, 0.5, 1.5)
scales <- rep(1, 3)

shapes <- c(1.4, 1.4)
scales <- c(1, 1.5)

# par(mfrow = c(1, 2), mar = c(4.5, 4, 1, 1), las = 1)
ts <- seq(0, 5, by = 0.01)

hconst <- function(x, threshold){
    res <- ifelse(x<=threshold, 0, (x-threshold))
    return(res)
}

Sconst <- function(x, threshold){
    H <- ifelse(x<=threshold, 0, (x-threshold)^2/2)
    res <- exp(-H)
    return(res)
}

thresholds <- c(2, 3)

# hazards
plot(0, 0, type = 'n', xlim = range(ts), ylim  = c(0, 3), xlab = "Time t", ylab = "Hazard function h(t)")
## for (i in 1:length(shapes)){
##     St <- 1 - pweibull(ts, shape = shapes[i], scale = scales[i])
##     ht <- dweibull(ts, shape = shapes[i], scale = scales[i]) / St
##     lines(ts, ht, col = colors[i], lwd = 2, lty = 1)
##     }
for (i in 1:length(thresholds)){
    ht <- hconst(ts, thresholds[i])
    lines(ts, ht, col = colors[i], lwd = 2, lty = 1)
}

# S(t)
plot(0, 0, type = 'n', xlim = range(ts), ylim  = c(0, 1), xlab = "Time t", ylab = "Survival function S(t)")
for (i in 1:length(shapes)){
    St <- Sconst(ts, thresholds[i])
    lines(ts, St, col = colors[i], lwd = 2, lty = 1)
    }
``` 







```{r ch24, echo=F}
#res <- mantelCoxHR(time, event, cholestase)
event <- sakk$death
res2 <- mantelCoxHR(time, event, treat)
Therapie <- treat
res3 <- (coxph(Surv(time, event)~ Therapie))

res3HR <- summary(res3)$conf.int[1]
res3HRlow <- summary(res3)$conf.int[3]
res3HRup <- summary(res3)$conf.int[4]
``` 



### Hazard ratio

Let $h_A(t)$ and $h_B(t)$ denote the hazard functions in groups A and B. The *proportional hazards assumption* implies a time-constant *hazard ratio*

\begin{equation*}
\mbox{HR} = {h_A(t)}/{h_B(t)}.
\end{equation*}

The hazard ratio can be interpreted as


1. (instantaneous) relative risk at any time $t>0$:

\begin{equation*}
\mbox{HR} = \frac{h_A(t)}{h_B(t)}\approx 
\frac{{\P(t < T_A < t+h \given T_A>t)}/{h}}{{\P(t < T_B < t+h \given T_B>t)}/{h}} 
\equiv \frac{{\P(t < T_A < t+h \given T_A>t)}}{{\P(t < T_B < t+h \given T_B>t)}}
\end{equation*}

2.  ratio of the cumulative hazard functions at any time $t>0$:

\begin{equation*}
\mbox{HR} = \frac{H_A(t)}{H_B(t)} = \frac{\log S_A(t)}{\log S_B(t)}
\end{equation*}
so the survival function in group A is the survival function in group B to the power of HR: 
\begin{equation*}
S_A(t) = S_B(t)^{\scriptsize \mbox{HR}}.
\end{equation*}




<!-- Figure \@ref(fig:survhazard) shows two different settings of hazard functions  -->
<!-- (constant and non-constant) that both have the same hazard ratio of 2. -->





```{r dataprep-sakk2, echo=FALSE}
howmany <- 10
howmany2 <- 5

## table
os <- as.character(Surv(round(sakk$os, 1), sakk$death))
tttd <- as.character(Surv(round(sakk$os, 1), sakk$death))
sex <- factor(as.numeric(sakk$sex == "F"), levels = 0:1, labels = c("Mann", "Frau"))
trt2 <- factor(sakk$trt, levels = c("A", "B"), labels = c("RT + CT", "RT"))

sakk.tab <- cbind(sakk$upn, sex, disp(sakk$age, 1), trt2, sakk[c("n", "t", "ps")], os, tttd)
sakk.tab <- sakk.tab[1:howmany,]
sakk.tab <- sakk.tab[order(sakk$os[1:howmany], decreasing = TRUE),]

sakk.tab <- head(sakk.tab, howmany2)
dimnames(sakk.tab)[[2]] <- c("Patient", "Geschlecht", "Alter", "Behandlung", "LK-Status", "Stadium", "PS", "OS", "TTT")
sakk.tab$Patient <- 1:howmany2


time <- sakk$os
event <- sakk$death
treat <- factor(sakk$trt, labels = c(" (RT + CT)", " (RT)"))
sakk$trt <- treat

sakk.rtct <- sakk[sakk$trt == "A", ]
sakk.rt <- sakk[sakk$trt == "B", ]

dat.tmp <- sakk[, c("os", "death", "trt", "ps", "age", "sex")]
## names(dat.tmp) <- c("Zeit", "Tod", "Therapie", "Performance.Status", "Alter", "sex")
dat.tmp$sex <- factor(dat.tmp$sex, labels = c(" (F)", " (M)"))
dat.tmp$sex <- factor(dat.tmp$sex, levels = c(" (M)", " (F)"))
``` 
```{r ch28, echo = FALSE}
model.cox0 <- coxph(Surv(os, death) ~ trt2, data = dat.tmp)
#myprint.glm(model2)
model.cox1 <- coxph(Surv(os, death) ~ trt2 + sex, data = dat.tmp)
#myprint.glm(model2)
model.cox2 <- coxph(Surv(os, death) ~ trt2 + sex + age, data = dat.tmp)
``` 

The hazard ratio can be calculated from the output of the log-rank
test as the ratio of the relative event rates (observed/expected) in
the two groups.  Only the observed and expected number of cases are
required. This simple estimate is know as the Pike hazard ratio
estimate and has been shown to slightly underestimate larger effects.
It has only little bias for hazard rates typically observed in clinical trials. 

```{r echo=TRUE}
lrTest <- survdiff(Surv(time, death) ~ treat, data = sakk)
(observed <- lrTest$obs)
(expected <- lrTest$exp)
(EventRates <- observed/expected)
HR <- EventRates[2]/EventRates[1]
SElogHR <- sqrt(sum(1/expected))
printWaldCI(log(HR), SElogHR, FUN = exp)
``` 
In the example the hazard ratio turns out to be $\mbox{HR}=`r round(HR,3)`$. 

#### The Cox model {-}
The (semiparametric) *Cox model* assumes that the hazard function $h_i(t)$ of individual $i$ with explanatory variables $\boldsymbol{ x}_i$ has the form

\begin{equation*}
h_i(t; \boldsymbol{ x}_i) = \exp(\boldsymbol{ x}_i^{\top} \boldsymbol{ \beta}) \cdot h_0(t),
\end{equation*}

where $h_0(t)$ is the *baseline hazard function*. Ratios of hazard functions are time-constant: 

\begin{equation*}
\frac{h_i(t; \boldsymbol{ x}_i)}{h_j(t; \boldsymbol{ x}_j)} = 
\frac{\exp(\boldsymbol{ x}_i^{\top} \boldsymbol{ \beta})}
{\exp(\boldsymbol{ x}_j^{\top} \boldsymbol{ \beta})},
\end{equation*}

i.e. we have proportional hazards. A *profile likelihood approach* allows to estimate the log hazard ratios $\boldsymbol{ \beta}$, no matter which form 
$h_0(t)$ has. To estimate the hazard ratio,
we use *Cox-Regression* as in the following example.


:::{.example #sakk name="continued"}
Cox regression in Example \@ref(exm:sakk):
:::
```{r ch29, echo = TRUE, results = "asis"}
model.cox0 <- coxph(Surv(os, death) ~ trt2, data = dat.tmp)
knitr::kable(tableRegression(model.cox0, latex = FALSE, xtable = FALSE))
``` 
The comparison RT vs. RT+CT gives $\mbox{HR}=`r round(exp(coef(model.cox0)),2)`$ with relatively large confidence interval, very close to the one obtained with Pike's method based on the log-rank test. There is no evidence for a treatment effect ($p=0.19$).

#### Adjusting in survival analysis {-}

```{r }
sakk$treat2 <- factor(sakk$trt, labels = c("RT + CT", "RT"))
```

There may be differences between treatment groups in important baseline characteristics. Table \@ref(tab:sakkGender) shows the distribution of gender in the two treatment groups in Example \@ref(exm:sakk), which is surprisingly unbalanced (percentage female `r round(table(sakk$sex, sakk$treat2)[1,1]/sum(table(sakk$sex, sakk$treat2)[,1])*100, 0)`\% resp.\ `r round(table(sakk$sex, sakk$treat2)[1,2]/sum(table(sakk$sex, sakk$treat2)[,2])*100, 0)`\%). It is recommended to adjust the treatment effect for potential confounders at baseline, which can be done with Cox regression.


```{r sakkGender, echo=FALSE, results="asis"}
library(xtable)
sakk$treat2 <- factor(sakk$trt, labels = c("RT + CT", "RT"))
table_data <- table(sakk$sex, sakk$treat2)
colnames(table_data) <- c("RT + CT", "RT")  # Set column names

kable(table_data,
      caption = "Distribution of gender in the two treatment groups in Example \\@ref(exm:sakk).",
      booktabs = TRUE, escape = FALSE, caption.placement = "top", 
      label = NA) %>%
  kable_styling(latex_options = "striped", full_width = FALSE)
``` 


:::{.example #sakk name="continued"}
Adjusting for baseline values with Cox regression in Example \@ref(exm:sakk):
:::

```{r ch37, echo = TRUE, results = "asis"}
model.cox1 <- coxph(Surv(os, death) ~ trt 
                    + sex, data = dat.tmp)
knitr::kable(tableRegression(model.cox1, latex = FALSE, xtable = FALSE))
``` 

The adjusted hazard of death (instantaneous death risk) is increased by 
$`r round((exp(coef(model.cox1)[1])-1)*100)`$\% for RT relative to RT + CT 
($p=`r biostatUZH::formatPval(summary(model.cox1)[[7]][1,5])`$). 
Women have a $`r round(100*(1-exp(coef(model.cox1)[2])))`$\% reduced hazard 
of death ($p=`r biostatUZH::formatPval(summary(model.cox1)[[7]][2,5])`$) 
compared to men. However, there is no evidence for a difference 
in both cases as the corresponding $P$-values are large.



## Sample size in survival studies
Both the *number of events* and the *total number of patients* 
are of interest in a survival study.

### Total number of events
There is a simple formula for the required total number of events [@collett, Chapter 10)]:

\begin{equation*}
d = \frac{ 4 (u + v)^2}{ \Delta^2},
\end{equation*}
where $\Delta$ is the log hazard ratio to be detected.

The number of events can be calculated with 
the `R`function `biostatUZH::survEvents()`:
```{r echo=TRUE}
library(biostatUZH)
survEvents(HR = 0.65, power = 0.9, sig.level=0.05)
``` 

### Total number of patients

The required total number of patients $n$ can be found from

\begin{equation*}
n = d / \Pr(\mbox{event}),
\end{equation*}

where $\Pr(\mbox{event})$ is calculated based on the assumed survival 
functions in the two groups and assumptions on 
the *accrual period* $a$ and the *follow-up period* $f$.


:::{.example}
The survival probability of females in the lung cancer data from 
@Loprinzi1994 is shown in Figure \@ref(fig:gglungcancer).
:::

```{r gglungcancer, echo=TRUE, fig.width = 7, fig.height = 4.6, fig.cap="Kaplan-Meier estimate of the survival curve of females in the lung cancer data from @Loprinzi1994."}
data(cancer, package = "survival")
cancer.female <- subset(cancer, sex == 2)
survObj <- Surv(time = cancer.female$time, 
                event = (cancer.female$status == 2))
fit <- survfit(survObj ~ 1)
ggsurvplot(fit, data = cancer.female)
``` 

In order to detect a hazard ratio of $0.65$ with power 90\% for 
accrual and follow-up time period of 400 days, 
379 patients are required:

```{r echo=TRUE}
res <- sampleSizeSurvival(HR = 0.65, power=.9, sig.level=0.05, 
                          a.length = 400, f.length = 400, 
                          dist = "non-parametric", survfit.ref = fit)
print(t(res))
``` 

Instead of a non-parametric fit of the survival curves, the function can also be given a parametric input for the survival curves such as a Weibull or exponential distribution with specified parameters.





## Time-varying explanatory variables

Time-varying explanatory variables, e.g. exposure yes/no, can be dealt with by


-  splitting the follow-up into parts with constant covariate values and
-  treating the parts as distinct subjects.

This approach requires allowance for late entries and is valid if changes in explanatory variables are unrelated to the underlying risk of failure. We will now see two examples of time-dependent analyses.


:::{.example}
The PBC study is about treatment of primary biliary cirrhosis (PBC) of the liver. We will use the first 312 cases in this dataset from the `survival` package since they participated in the randomized trial and contain largely complete data. The `status` at endpoint can be 0 = censored, 1 = transplant or 2 = dead.
:::

```{r echo=TRUE}
library(survival)
data("pbc")
sel <- c("id", "time", "status", "trt", "age", "sex", "bili", "protime")
## baseline data
head(pbc[,sel])
```

Variables bili and protime are time-dependent measurements. The baseline data shown above, in contrast, only include baseline measurements of these covariates that have multiple measurements over time.

```{r echo=TRUE}
sel <- c("id", "futime", "status", "trt", "age", "sex", "day", "bili",
         "protime")
head(pbcseq[,sel], 14)
```

In a baseline analysis (including only baseline measurements), first without and then with adjustment for covariates, we obtain the following results:

```{r echo=TRUE, results="asis"}
## baseline fit for first 312 patients
fit0 <- coxph(Surv(time, status == 2) ~ trt, 
              data = pbc, subset = (id <= 312))
fit1 <- coxph(Surv(time, status == 2) ~ trt + log(bili) + log(protime),
              data = pbc, subset = (id <= 312))
knitr::kable(tableRegression(fit0, latex = FALSE, xtable = FALSE))
knitr::kable(tableRegression(fit1, latex = FALSE, xtable = FALSE))
```

A time-dependent analysis includes all measurements. First, we need to prepare the data accordingly. The data preparation below is adopted from vignette `timedep.pdf` in package `survival`.

```{r echo=TRUE}
temp <- subset(pbc, id <= 312, select = c(id:sex, stage)) # baseline
pbc2 <- tmerge(temp, temp, id = id, death = event(time, status)) #set range
pbc2 <- tmerge(pbc2, pbcseq, id = id, ascites = tdc(day, ascites),
               bili = tdc(day, bili), albumin = tdc(day, albumin), 
               protime = tdc(day, protime), alk.phos = tdc(day, alk.phos))

head(pbc2)
```

```{r echo=TRUE, results="asis"}
## time-dependent fit for first 312 patients
fit2 <- coxph(Surv(tstart, tstop, death == 2) ~ trt + log(bili) + 
                log(protime), data = pbc2)
knitr::kable(tableRegression(fit2, latex = FALSE, xtable = FALSE))
```



:::{.example}
Survival by tumor response revisited, see Section \@ref(sec:breslow). This example is about survival in patients with advanced lung cancer shown in Figure \@ref(fig:gglungcancerall).
:::


```{r gglungcancerall, echo=TRUE, fig.cap="Kaplan-Meier estimate of the survival curve of patients with advanced lung cancer."}
KMfit <- survfit(Surv(time/365.25, status) ~ 1, data = lung)
ggsurvplot(KMfit, xlab = "Years post diagnosis", ylab = "Survival",
           conf.int = TRUE)
```


```{r echo=FALSE, warning=FALSE}
## a visit at baseline and at every month within the first year
set.seed(2020)
maxVisit <- 12
nvisits <- floor(pmin(lung$time/30.5, maxVisit))+1
response <- time <- matrix(NA, nrow=nrow(lung), ncol=maxVisit+1)
n <- nrow(response)
lung$id <- c(1:n)
for(i in 1:n){
    response[i,1:(nvisits[i])] <- as.numeric(cumsum(rbinom(nvisits[i], size=1, prob=.05))>0)
    time[i,1:(nvisits[i])] <- 0:(nvisits[i]-1)
}
colnames(response) <- as.character(c(0:12))

cumResponse <- response
for(i in 1:n)
    cumResponse[i,] <- cumsum(response[i,])

responseVec <- cbind(kronecker(c(1:n), rep(1, (1+maxVisit))), as.vector(t(response)), as.vector(t(time*30.5)), as.vector(t(cumResponse)))

sel <- !is.na(responseVec[,2])
responseVec <- responseVec[sel,]
colnames(responseVec) <- c("id", "response", "time", "cumresponse")
responseVec <- as.data.frame(responseVec)

sel <- (responseVec$time==0) | (responseVec$cumresponse==1)
responseVec <- responseVec[sel,]
responseVec <- responseVec[,-4]
```

We now randomly generate tumor "responders" with a probability of $0.05$ to become a responder at every month within the first year.
```{r echo=TRUE}
head(response, 3)

responder <- (apply(response, 1, sum, na.rm = TRUE) > 0)
table(responder)
```

```{r echo=FALSE}
mytime <- lung$time/365.25
responderFit <- glm(responder ~ mytime, family = binomial)
## tableRegression(responderFit)
```

For illustration, we first show a wrong analysis comparing responder groups as in Figure \@ref(fig:responder):
```{r responder, echo=TRUE, fig.cap="Kaplan-Meier estimate of the survival curves of patients with advanced lung cancer, by responder status (wrong analysis)."}
badfit <- survfit(Surv(time/365.25, status) ~ responder, data = lung)
ggsurvplot(badfit, xlab = "Years post diagnosis", ylab = "Survival",
           conf.int = TRUE, pval = TRUE)
```

```{r echo=TRUE, results="asis"}
badcoxfit <- coxph(Surv(time/365.25, status) ~ responder, data = lung)
knitr::kable(tableRegression(badcoxfit, latex = FALSE, xtable = FALSE))
```

There appears to be an effect of tumor response on survival, but it should not have an effect as responders were generated randomly. The analysis is flawed as it violates "Breslow's first rule" and is subject to *time-dependent bias*. More precisely, the bias is that the probability to be a responder increases with time.

At the beginning, we do not know who becomes a responder. We should therefore treat it as a time-dependent covariate. For the correct analysis with time-dependent covariate, we need to split the data by responder status. This augmented data set looks as follows:

```{r echo=FALSE}
newdata <- tmerge(data1=lung, data2=lung, id=id,
                  endpt = event(time, status))
newdata <- tmerge(newdata, responseVec, id=id,
                  response = tdc(time, response))
newdata <- newdata[,c("id", "tstart", "tstop", "response", "status",
                      "time", "endpt")]

newdata$response <- ifelse(is.na(newdata$response), 0, newdata$response)
## newdata$endpt <- ifelse(newdata$endpt<1, 1, 2)
```

```{r echo=TRUE}
head(newdata)
```

```{r echo=TRUE, results="asis"}
goodcoxfit <- coxph(Surv(tstart, tstop, endpt==2) ~ response, data=newdata)
knitr::kable(tableRegression(goodcoxfit, latex = FALSE, xtable = FALSE))
```

In the correct analysis, there is no evidence for an effect of tumor response on survival, as it should be for randomly generated responders.



## Additional references

Additional references are @bland (Ch. 16 Time to Event Data),  @matthews (Sec. 7.5 Survival Analysis) and @collett. The Pike hazard ratio estimate based on the output from the log-rank test is described in @berry1991. Studies where the methods from this chapter are applied in practice are for example @blue2001, @colorectal2000, @zar2007.
